#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

// 操作符
// 算术操作符
// 移位操作符
// 位操作符
// 赋值操作符
// 单目操作符
// 关系操作符
// 逻辑操作符
// 条件操作符
// 逗号操作符
// 下标引用、函数调用和结构成员


// # 算数操作符
// + - * / %

//int main() 
//{
//	int a = 5 / 2;	// 整数除法得到整数，得到商，商为2余为1
//	int b = 5 % 2;	// 取模，得到余，余为1
//	printf("a = %d\n", a);
//	printf("b = %d\n", b);
//
//	// 如果要5除2为2.5，那么某一边就需要为小数，即浮点数
//	double c = 5 / 2.0;// 得到2.500000	，默认保留6位
//	printf("c = %lf\n", c);
//	return 0;
//}

// # 移位操作符

// >> 右移操作符
//int main() 
//{
//	int a = 16;
//	// >> 右移操作符
//
//	int b = a >> 1;
//	// 16的二进制：00000000 00000000 00000000 00010000
//	// 右移 - 1. 算术右移	右边丢弃，左边补原符号位 基本上都是算术移法
//	//      - 2. 逻辑右移	右边丢弃，左边补0
//	// 00000000 00000000 00000000 00001000，结果是8
//	printf("%d\n", b);
//	// 所以，右移一位有除二的效果
//
//	// 看看 -1
//	// 整数的二进制表示有：原码、反码、补码
//	// 存储到内存的是补码
//	// 
//	int c = -1;
//	int d = c >> 1;
//	// -1的二进制：	10000000 00000000 00000000 00000001  原码
//	// 符号位不变，其他按位取反，11111111 11111111 11111111 11111110  反码
//	// 补码再反码基础上加一，	 11111111 11111111 11111111 11111111  补码
//	// 进行右移，实际上是对补码进行右移
//	// 11111111 11111111 11111111 11111111
//	//  11111111 11111111 11111111 11111111
//	// 然后补多一个1，如下，发现还是和原来一样
//	// 11111111 11111111 11111111 11111111
//	// 所以打印还是-1
//	printf("%d\n", d);
//	return 0;
//}

// << 左移操作符
//int main() 
//{
//	int a = 5;
//	int b = a << 1;
//	// 5 - 00000000 00000000 00000000 00000101
//	// 进行左移，补0
//	//	   00000000 00000000 00000000 00001010  就成了 10
//	// 可以说 左移1位有乘2的效果
//	// 下面应该打印10
//	printf("%d", b);
//	return 0;
//}

// 位操作符
//int main() 
//{
//	// 注意，都是用补码进行运算的，为什么？因为内存存储的就是它的补码，如果是负数的话，得先写出补码
//	// & - 按 二进制位 与，简称 按位与
//	int a = 3;
//	int b = 5;
//	int c = a & b;
//	// 00000000 00000000 00000000 00000011
//	// 00000000 00000000 00000000 00000101
//	// 00000000 00000000 00000000 00000001 结果就是 1
//	// 
//	printf("%d\n", c);
//
//
//	// | - 按位或
//	int d = 3;
//	int e = 5;
//	int f = d | e;
//	// 00000000 00000000 00000000 00000011
//	// 00000000 00000000 00000000 00000101
//	// 00000000 00000000 00000000 00000111 结果就是 7
//	printf("%d\n", f);
//
//
//	// ^ - 按位异或
//	// 相同为0，相异为1
//	int h = 3;
//	int i = 5;
//	int j = h ^ i;
//	// 00000000 00000000 00000000 00000011
//	// 00000000 00000000 00000000 00000101
//	// 00000000 00000000 00000000 00000110 结果就是 6
//	printf("%d\n", j);
//
//	return 0;
//}


// 交换两个int的值，不使用第三个变量

//int main() 
//{
//	int a = 3;
//	int b = 5;
//	printf("before: a = %d, b = %d\n", a, b);
//	// 1. 加减法 - 可能会溢出
//	//a = a + b;
//	//b = a - b;
//	//a = a - b;
//
//	// 2. 异或法
//	a = a ^ b;	// 011 ^ 101  110
//	b = a ^ b;	// 110 ^ 101  011
//	a = a ^ b;	// 110 ^ 011  101
//
//
//	printf("after: a = %d, b = %d\n", a, b);
//
//	return 0;
//}


// 求一个整数存储再内存中的二进制中1的个数

//int main() 
//{
//	int num = 0; // 101
//	scanf("%d", &num);
//	// 即统计num的补码，1的个数有多少个
//	int count = 0;
//	/*while (num) 
//	{
//		if (num % 2 == 1) 
//		{
//			count++;
//		}
//		num = num / 2;
//	}*/
//	// 上面这个方法有问题，不能输负数
//
//	// 
//	int i = 0;
//	for (i = 0; i < 32; i++) 
//	{
//		if (1 == ((num >> i) & 1)) 
//		{
//			count++;
//		}
//	}
//
//	printf("%d\n", count);
//	return 0;
//}


// 复合操作符

//int main() 
//{
//	int a = 10;
//	a = a + 2;
//	a += 2;
//
//	a = a - 2;
//	a -= 2;
//
//	a = a >> 1;
//	a >>= 1;
//
//	a = a & 1;
//	a &= 1;
//
//	//....
//
//	return 0;
//}


// 单目操作符


//int main() 
//{
//	int a = 10;
//	int* p = &a;	// 取地址操作符
//	*p = 20;		// 解引用操作符/间接访问操作符
//	return 0;
//}

//int main() 
//{
//	int a = 10;
//	char c = 'a';
//	char* p = &c;
//	int arr[10] = { 0 };
//	// sizeof 计算变量所占内存空间大小，单位是字节
//	printf("%d\n", sizeof(a));
//	printf("%d\n", sizeof(int));
//
//	printf("%d\n", sizeof(c));
//	printf("%d\n", sizeof(char));
//
//	printf("%d\n", sizeof(p));
//	printf("%d\n", sizeof(char*));
//
//	printf("%d\n", sizeof(arr));
//	printf("%d\n", sizeof(int [10]));
//	return 0;
//}

//int main() 
//{
//	short s = 0;
//	int a = 10;
//	printf("%d\n", sizeof(s = a + 5));	// 2
//	printf("%d\n", s);	// 0
//	return 0;
//}


//int main() 
//{
//	int a = 0;
//	// ~ 按位取反
//	// 00000000 00000000 00000000 00000000
//	// 11111111 11111111 11111111 11111111 - 补码
//	// 11111111 11111111 11111111 11111110 - 反码
//	// 10000000 00000000 00000000 00000001 - 原码
//	// -1
//	printf("%d\n", ~a);
//
//	int b = 11;
//	// 00000000 00000000 00000000 00001011  如何把第3位变成1？ -> 按位或上1
//	// 00000000 00000000 00000000 00000100
//	// 上面这个东西，不要直接写|4嘛，写成 1<<2
//	// 00000000 00000000 00000000 00001111	15
//	b = b | (1 << 2);
//	printf("%d\n", b);
//	// 00000000 00000000 00000000 00001111  现在改回去呢？把第3位变成0？ -> 按位与上0
//	// 11111111 11111111 11111111 11111011
//	// 上面这个东西，怎么产生？ 把1<<2，然后按位取反
//	// 00000000 00000000 00000000 00001011
//	// 
//	b = b & (~(1 << 2));
//	printf("%d\n", b);
//	return 0;
//}

//void test1(int arr[]) // 传的地址过来，那么接受的就是指针，那么指针大小要么4字节，要么8字节
//{
//	printf("%d\n", sizeof(arr));
//}
//
//void test2(char ch[])
//{
//	printf("%d\n", sizeof(ch));
//}
//
//int main() 
//{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//	printf("%d\n", sizeof(arr));
//	printf("%d\n", sizeof(ch));
//	test1(arr);	// 说了好多次的了，数组传参 传的是，数组首元素的首地址
//	test2(ch);
//	return 0;
//}

//int main() 
//{
//	int i = 0;
//	int a = 0;
//	int b = 2;
//	int c = 3;
//	int d = 4;
//	// 将输出什么？
//	//i = a++ && ++b && d++;// a = 1 b = 3 c = 3 d = 5  错了 // 1 2 3 4
//	i = a++ || ++b || d++;// a = 1 b = 3 c = 3 d = 5	错了 // 1 3 3 4
//	printf(" a = %d\n b = %d\n c = %d\n d = %d\n", a, b, c, d);
//	
//	// 总的来说，&& ，有假，后面就不会执行了
//	// || 有假，后面继续执行，有一个真，后面就不会执行了
//	
//	return 0;
//}


// 下标操作符 []

//int main() 
//{
//	int a[10] = { 0 };
//	a[4] = 5;
//	return 0;
//}


// 函数调用操作符 ()

//int get_max(int x, int y) 
//{
//	return x > y ? x : y;
//}
//
//
//int main() 
//{
//	int a = 10;
//	int b = 20;
//	int max = get_max(a, b);
//	printf("max = %d\n", max);
//	return 0;
//}


// 点 操作符

// 学生
// 一种类型，叫结构体类型，类型嘛，就是用来创建变量的
// 创建了一个结构体类型，struct Stu
//struct Stu 
//{
//	// 成员变量
//	char name[20];
//	int age;
//	char id[10];
//};
//
//int main() 
//{
//	int a = 10;
//	// 用结构体类型-struct Stu这个类型，创建了一个结构体变量st1，并初始化
//	struct Stu st1 = { "勒布朗", 20, "20210210" };
//	// 结构体变量.成员名
//	//printf("%s\n", st1.name);
//	//printf("%d\n", st1.age);
//	//printf("%s\n", st1.id);
//
//	struct Stu* ps = &st1;
//
//	printf("%s\n", (*ps).name); // 这种写法嗦咯，直接指针->成员变量
//	printf("%s\n", ps->name);
//	printf("%d\n", ps->age);
//	printf("%s\n", ps->id);
//	
//	return 0;
//}


// 隐式类型转换 - 整型提升，算术转换


// C的整型算术运算是以默认整型类型（int）的精度来进行的
// 为了获取这个精度，表达式中的字符和短整型操作数再使用之前会被转换成普通整型（int）
// 这种转换就称为整型提升


//int main() 
//{
//	char a, b, c;
//	a = 3;
//	// 00000000 00000000 00000000 00000011 
//	// char类型 只能放一个字节，调最低位的字节放进去
//	// 00000011 3
//
//	b = 127;
//	// 01111111	127
//
//	c = a + b;
//	// 如何相加？
//	// 00000011
//
//	// 01111111
//	// 发生整型提升
//	// 按符号位补，所以高位补0
//	// 00000000 00000000 00000000 00000011
//	// 00000000 00000000 00000000 01111111
//
//	// 00000000 00000000 00000000 10000010 放到C里面
//
//	// 10000010 
//	// 按符号位补，所以高位补1
//	// 11111111 11111111 11111111 10000010 - 补码
//	// 11111111 11111111 11111111 10000001 - 反码
//	// 10000000 00000000 00000000 01111110 - 原码
//	// 所以 打印 -126
//	printf("%d\n", c); // -126
//	
//	// 整型提升的意义
//	// 运算是在CPU中的ALU（算术逻辑单元）进行的，这个单元的操作数的字节长度一般就是int的字节长度
//	// 同时也是CPU通用寄存器的长度
//	// 所以，即使两个char类型相加，在CPU上执行的时候实际上是转换为CPU内整型操作数的标准长度进行的
//
//	return 0;
//}


// 算术转换



// 操作符的属性
// 优先级
// 结合性
// 求值顺序

int main()
{
	int a = 10;
	int b = 20;
	int c = b + a * 3;
	printf("c = %d\n", c);
	return 0;
}