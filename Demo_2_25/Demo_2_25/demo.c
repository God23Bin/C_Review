#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

//C语言类型

//1. 内置类型
//char
//short
//int
//long
//float
//double

//2. 自定义类型（构造类型）

//int main() 
//{
//	int a = 10;
//	float f = 10.0;
//	return 0;
//}

// 整型家族

//char
//	unsigned char	0 -- 255
//	signed char		-128 -- 127
//short
//	unsigned short
//	signed short
//int
//	unsigned int
//	signed int
//long
//	unsigned long
//	signed long

// 构造类型如下：

//数组类型
//结构体类型
//枚举类型
//联合类型

// 指针类型
// 他们大小都是4字节/8字节，目的都是为了存储地址

// 空类型

//void test() 
//{
//	printf("哈哈哈哈\n");
//}
//
//int main() 
//{
//	test();
//	return 0;
//}

// 整型在内存中的存储

//int main() 
//{
//	int a = 20;
//	int b = -10;
//	return 0;
//}

// 原码、反码、补码

// 整数，有符号，无符号，都有原码、反码、补码
// 对于有符号来说，原反补不一样；无符号原反补一样；
// 有符号中，有正负，正的原反补也是一样的，负的就不一样

int main()
{
	int a = 20;	// 4个字节
	// 00000000 00000000 00000000 00010100 - 原码
	// 00000000 00000000 00000000 00010100 - 反码
	// 00000000 00000000 00000000 00010100 - 补码
	// 0x 00 00 00 14
	int b = -10;
	// 10000000 00000000 00000000 00001010 - 原码

	// 11111111 11111111 11111111 11110101 - 反码

	// 11111111 11111111 11111111 11110110 - 补码
	// 0x ff ff ff f6
	// 所以可以通过内存看出
	// 存整数的时候存的是整数的二进制补码
	return 0;
}

// 为什么要存补码呢？
// 在计算机系统中，数值一律用补码来表示和存储。
// 原因在于，使用补码，可以将符号位和数值域统一处理；
// 同时，加减法也可以统一处理（CPU只有加法器）
// 此外，补码与原码相互转换的运算过程是相同的，不需要额外的硬件电路


// 综上，梳理下

// 整数-整型
// 1. 有符号数	正数：原反补 相同
//				负数：原反补不同
// 2. 无符号数	原反补 相同


// 大端（字节序）存储模式
//		数据的低位，保存在内存的高地址；数据的高位，保存在内存的低地址
// 小端（字节序）存储模式
//		数据的低位，保存在内存的低地址；数据的高位，保存在内存的高地址