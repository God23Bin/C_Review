#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
#include <string.h>

//C语言类型

//1. 内置类型
//char
//short
//int
//long
//float
//double

//2. 自定义类型（构造类型）

//int main() 
//{
//	int a = 10;
//	float f = 10.0;
//	return 0;
//}

// 整型家族

//char
//	unsigned char	0 -- 255
//	signed char		-128 -- 127
//short
//	unsigned short
//	signed short
//int
//	unsigned int
//	signed int
//long
//	unsigned long
//	signed long

// 构造类型如下：

//数组类型
//结构体类型
//枚举类型
//联合类型

// 指针类型
// 他们大小都是4字节/8字节，目的都是为了存储地址

// 空类型

//void test() 
//{
//	printf("哈哈哈哈\n");
//}
//
//int main() 
//{
//	test();
//	return 0;
//}

// 整型在内存中的存储

//int main() 
//{
//	int a = 20;
//	int b = -10;
//	return 0;
//}

// 原码、反码、补码

// 整数，有符号，无符号，都有原码、反码、补码
// 对于有符号来说，原反补不一样；无符号原反补一样；
// 有符号中，有正负，正的原反补也是一样的，负的就不一样


//int main()
//{
//	int a = 20;	// 4个字节
//	// 00000000 00000000 00000000 00010100 - 原码
//	// 00000000 00000000 00000000 00010100 - 反码
//	// 00000000 00000000 00000000 00010100 - 补码
//	// 0x 00 00 00 14
//	int b = -10;
//	// 10000000 00000000 00000000 00001010 - 原码
//
//	// 11111111 11111111 11111111 11110101 - 反码
//
//	// 11111111 11111111 11111111 11110110 - 补码
//	// 0x ff ff ff f6
//	// 所以可以通过内存看出
//	// 存整数的时候存的是整数的二进制补码
//	return 0;
//}

// 为什么要存补码呢？
// 在计算机系统中，数值一律用补码来表示和存储。
// 原因在于，使用补码，可以将符号位和数值域统一处理；
// 同时，加减法也可以统一处理（CPU只有加法器）
// 此外，补码与原码相互转换的运算过程是相同的，不需要额外的硬件电路


// 综上，梳理下

// 整数-整型
// 1. 有符号数	正数：原反补 相同
//				负数：原反补不同
// 2. 无符号数	原反补 相同


// 大端（字节序）存储模式
//		数据的低位，保存在内存的高地址；数据的高位，保存在内存的低地址
// 小端（字节序）存储模式
//		数据的低位，保存在内存的低地址；数据的高位，保存在内存的高地址



// 写一段代码，告诉我当前机器的字节序

	//int a = 20;
	// 0x 00 00 00 14

	// 低地址->高地址
	// 如果是大端存储
	// 00 00 00 14
	// 如果是小端存储
	// 14 00 00 00

	// 解题思路
	// 拿出第一个字节，如果是14，那么就是小端，如果是00，那么就是大端


//int check_sys(char* a) 
//{
//	// 拿一个字节的内容
//		// 通过指针，char指针访问一个字节（指针类型的两个意义）
//	char* p = (char*)&a;
//	// 优化下
//	//if (*p == 1)
//	//{
//	//	return 1;
//	//}
//	//else
//	//{
//	//	return 0;
//	//}
//	// 返回1，小端
//	// 返回0，大端
//	return *p;
//}
//
//int main() 
//{
//
//	int a = 1;
//	int res = check_sys(&a);
//	if (res == 1) 
//	{
//		printf("小端\n");
//	}
//	else 
//	{
//		printf("大端\n");
//	}
//	// 常见PC基本都是小端存储
//	return 0;
//}

// 回顾：指针类型的意义
// 1. 指针类型决定了指针解引用操作符能访问几个字节：char* p;*p访问1个字节；int* p; *p访问4个字节
// 2. 指针类型决定了指针+1，-1加的或减的是几个字节

//int main() 
//{
//	int a = 0x11223344;
//	//int* p = &a;
//	//*p = 0;	// 看内存可看出一下修改了4个字节
//
//	char* c = &a;
//	*c = 0;
//
//	return 0;
//}


// 输出什么？
//int main()
//{
//	char a = -1;	
//	// 10000000 00000000 00000000 00000001 - 原
//	// 11111111 11111111 11111111 11111110 - 反
//	// 11111111 11111111 11111111 11111111 - 补
//	// 但只能放1个字节 所以是
//	// 11111111
//	signed char b = -1;
//	unsigned char c = -1;
//	// 发生整型提升
//	// 按原符号位提升
//	// 无符号位，那么按位补0
//	printf("a = %d, b = %d, c = %d\n", a, b, c); // -1 -1 255
//	return 0;
//}


// 输出什么？
//int main()
//{
//	char a = -128;
//	// 10000000 00000000 00000000 10000000 - 原码 
//	// 11111111 11111111 11111111 01111111 - 反码 
//	// 11111111 11111111 11111111 10000000 - 补码 
//	// 10000000
//	// 整型提升
//	// 11111111 11111111 11111111 10000000
//	printf("%u\n", a);	// %u 按无符号打印，认为内存放无符号数，直接放的补码就是和原码反码一样
//	// %d - 打印十进制有符号数字
//	// %u - 打印十进制无符号数字
//	return 0;
//}

// 有符号char的范围 -128 --> 127
// 无符号char的范围 0 --> 255


//int main() 
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);
//	// 按照补码的形式进行运算，最后格式化为有符号整数
//
//	// -20
//	// 10000000 00000000 00000000 00010100 - 原码
//	// 11111111 11111111 11111111 11101011 - 反码
//	// 11111111 11111111 11111111 11101100 - 补码
//
//	// 10
//	// 00000000 00000000 00000000 00001010
//
//	// 进行相加
//	// 11111111 11111111 11111111 11101100
//	// 00000000 00000000 00000000 00001010
//	// 结果如下
//	// 11111111 11111111 11111111 11110110 - 补
//	// 那么它的反码就是
//	// 11111111 11111111 11111111 11110101
//	// 原码就是
//	// 10000000 00000000 00000000 00001010
//	// 所以最终结果应该为 -10
//
//	return 0;
//}


//#include <windows.h>
//
//// 结果打印什么？
//int main() 
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--) 
//	{
//		printf("%u\n", i);
//		Sleep(100);	// 睡上100毫秒
//	}
//	// 无限循环，死循环
//	// unsigned int的范围始终是正数
//	return 0;
//}


// 打印什么？
//int main() 
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++) 
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));
//	// 以为打印1000
//	// 结果打印255
//	// 为什么？
//
//	// -1 -2 -3 ... -1000
//
//	// strlen()找\0
//	// char的范围 -128 到 127；1000放不进去
//
//	// -1 -2 -3 ... -128 127 126 ... 3 2 1 0
//	// 所以是128 + 127个 = 255个
//	return 0;
//}


// 打印多少个hello world？

//unsigned char i = 0;
//int main() 
//{
//	for (i = 0; i <= 255; i++) 
//	{
//		printf("hello world\n");
//	}
//	// unsigned char 范围0-255，所以死循环
//	return 0;
//}


// 浮点数在内存中存储

//int main() 
//{
//	double d = 1E10; // 1.0 x 10的10次方
//	printf("%lf\n", d);
//	return 0;
//}

// 范围 limits.h, float.h 可以查到 

// 浮点数在内存中存储，正式开始

//int main() 
//{
//	int n = 9;
//	float* pF = (float*)&n;
//	printf("n的值为：%d\n", n);
//	printf("*pF的值为：%f\n", *pF);
//
//	*pF = 9.0;
//	printf("num的值为：%d\n", n);
//	printf("*pF的值为：%f\n", *pF);
//	//  n的值为：9
//	//	* pF的值为：0.000000
//	//	num的值为：1091567616
//	//	* pF的值为：9.000000
//	// 可以知道 浮点型的存储方式和整型的存储方式是不一样的
//	return 0;
//}


// 浮点数在内存中的存储

// 9.0
// 1001.0

// IEEE 754标准
// 二进制浮点数V可以表示下面形式

// (-1)^S * M * 2^E
// (-1)^S 表示符号位，当S=0时，V为正数；当S=1时，V为负数
// M表示有效数字，大于等于1，小于2
// 2^E表示指数位

// (-1)^0 * 1.001 * 2^3
// (-1)^S * M * 2^E
// S - 0
// M - 1.001
// E - 3
// 

// IEEE 754规定
// 对于32位的浮点数，最高位是符号位S，接着是8位指数E，剩下23位为有效数字M

// 对于64位的浮点数，最高位是符号位S，接着是11位指数E，剩下52位为有效数字M

// M 和 E 怎么存？
// M的话，1<=M<=2的，也就是说，M可以写成1.xxxx的形式
// 754规定，计算机内部保存M时，默认这个数第一位总是1，因此可以被舍去
// 只保存后面的xxxx，这样精度还高了一位，最后读取的时候，再把1加上去

// E的话，它是一个无符号整数（unsigned int）
// 这意味着，如果E为8位，那么它的取值范围是0-255；11位的话，就是0-2047.
// 但是我们知道，科学计数法中的E是可以出现负数的，所以754规定，存入内存时
// E的真实值必须再加上一个中间数，对于8位的E，这个中间数为127；对于11位的E，这个中间数位1023
// 

// 十进制 0.5
// 对应二进制 0.1
// (-1)^0 * 1.0 * 2^(-1)
// (-1)^S * M * 2^E
// S = 0
// M = 1.0
// E = -1 + 127 = 126

//int main() 
//{
//	float f = 5.5;
//	// 5.5
//	// 101.1
//	// (-1)^0 * 1.011 * 2^2
//	// S = 0
//	// M = 1.011
//	// E = 2 + 127 = 129
//	// 
//	// 0 10000001 01100000000000000000000
//
//	// 内存放的二进制，但是展示十六进制
//	// 那么我们转换下到十六进制，方便看
//	// 0 10000001 01100000000000000000000
//	// 0100 0000 1011 0000 00000000 00000000
//	// 4 0 b 0 0000
//	// 即40b00000
//}


// 取出来的时候
// E有3种情况
// 1. E不全为0也不全为1
// 此时，浮点数取出来，就E值减去127（或1023）得到真实值，再将有效数字M前加上第一位的1
// 2. E全为0
// 此时也一样，只是不加上第一位的1，而是还原为0.xxxx的形式。这样做是为了表示+-0，以及接近0很小的数
// 3. E全为1
// 此时表示无穷大


int main() 
{
	int n = 9;
	// 00000000 00000000 00000000 00001001 - 原反补
	// 然后按浮点数存储
	// 0 00000000 00000000000000000001001
	// E为全0
	// 那么M
	// (-1)^0 * 0.00000000000000000001001 * 2^-126
	// 无限接近0
	float* pF = (float*)&n;
	printf("n的值为：%d\n", n);
	printf("*pF的值为：%f\n", *pF);

	*pF = 9.0;
	// 1001.0
	// (-1)^0 * 1.0010 * 2^3
	// S = 0
	// M = 1.0010
	// E = 3 + 127 = 130 = 100000010
	// 0 10000010 00100000000000000000000
	// 换成十六进制Debug方便看存的是不是这样
	// 01000001 00010000 00000000 00000000
	// 十六进制：41 10 00 00

	printf("num的值为：%d\n", n); //01000001 00010000 00000000 00000000 当成整型直接打印 转成十进制就是 1091567616
	printf("*pF的值为：%f\n", *pF);
	//  n的值为：9
	//	* pF的值为：0.000000
	//	num的值为：1091567616
	//	* pF的值为：9.000000
	return 0;
}

// 以上就是浮点数在内存中的存储
