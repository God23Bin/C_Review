#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
#include <string.h>

//C语言类型

//1. 内置类型
//char
//short
//int
//long
//float
//double

//2. 自定义类型（构造类型）

//int main() 
//{
//	int a = 10;
//	float f = 10.0;
//	return 0;
//}

// 整型家族

//char
//	unsigned char	0 -- 255
//	signed char		-128 -- 127
//short
//	unsigned short
//	signed short
//int
//	unsigned int
//	signed int
//long
//	unsigned long
//	signed long

// 构造类型如下：

//数组类型
//结构体类型
//枚举类型
//联合类型

// 指针类型
// 他们大小都是4字节/8字节，目的都是为了存储地址

// 空类型

//void test() 
//{
//	printf("哈哈哈哈\n");
//}
//
//int main() 
//{
//	test();
//	return 0;
//}

// 整型在内存中的存储

//int main() 
//{
//	int a = 20;
//	int b = -10;
//	return 0;
//}

// 原码、反码、补码

// 整数，有符号，无符号，都有原码、反码、补码
// 对于有符号来说，原反补不一样；无符号原反补一样；
// 有符号中，有正负，正的原反补也是一样的，负的就不一样


//int main()
//{
//	int a = 20;	// 4个字节
//	// 00000000 00000000 00000000 00010100 - 原码
//	// 00000000 00000000 00000000 00010100 - 反码
//	// 00000000 00000000 00000000 00010100 - 补码
//	// 0x 00 00 00 14
//	int b = -10;
//	// 10000000 00000000 00000000 00001010 - 原码
//
//	// 11111111 11111111 11111111 11110101 - 反码
//
//	// 11111111 11111111 11111111 11110110 - 补码
//	// 0x ff ff ff f6
//	// 所以可以通过内存看出
//	// 存整数的时候存的是整数的二进制补码
//	return 0;
//}

// 为什么要存补码呢？
// 在计算机系统中，数值一律用补码来表示和存储。
// 原因在于，使用补码，可以将符号位和数值域统一处理；
// 同时，加减法也可以统一处理（CPU只有加法器）
// 此外，补码与原码相互转换的运算过程是相同的，不需要额外的硬件电路


// 综上，梳理下

// 整数-整型
// 1. 有符号数	正数：原反补 相同
//				负数：原反补不同
// 2. 无符号数	原反补 相同


// 大端（字节序）存储模式
//		数据的低位，保存在内存的高地址；数据的高位，保存在内存的低地址
// 小端（字节序）存储模式
//		数据的低位，保存在内存的低地址；数据的高位，保存在内存的高地址



// 写一段代码，告诉我当前机器的字节序

	//int a = 20;
	// 0x 00 00 00 14

	// 低地址->高地址
	// 如果是大端存储
	// 00 00 00 14
	// 如果是小端存储
	// 14 00 00 00

	// 解题思路
	// 拿出第一个字节，如果是14，那么就是小端，如果是00，那么就是大端


//int check_sys(char* a) 
//{
//	// 拿一个字节的内容
//		// 通过指针，char指针访问一个字节（指针类型的两个意义）
//	char* p = (char*)&a;
//	// 优化下
//	//if (*p == 1)
//	//{
//	//	return 1;
//	//}
//	//else
//	//{
//	//	return 0;
//	//}
//	// 返回1，小端
//	// 返回0，大端
//	return *p;
//}
//
//int main() 
//{
//
//	int a = 1;
//	int res = check_sys(&a);
//	if (res == 1) 
//	{
//		printf("小端\n");
//	}
//	else 
//	{
//		printf("大端\n");
//	}
//	// 常见PC基本都是小端存储
//	return 0;
//}

// 回顾：指针类型的意义
// 1. 指针类型决定了指针解引用操作符能访问几个字节：char* p;*p访问1个字节；int* p; *p访问4个字节
// 2. 指针类型决定了指针+1，-1加的或减的是几个字节

//int main() 
//{
//	int a = 0x11223344;
//	//int* p = &a;
//	//*p = 0;	// 看内存可看出一下修改了4个字节
//
//	char* c = &a;
//	*c = 0;
//
//	return 0;
//}


// 输出什么？
//int main()
//{
//	char a = -1;	
//	// 10000000 00000000 00000000 00000001 - 原
//	// 11111111 11111111 11111111 11111110 - 反
//	// 11111111 11111111 11111111 11111111 - 补
//	// 但只能放1个字节 所以是
//	// 11111111
//	signed char b = -1;
//	unsigned char c = -1;
//	// 发生整型提升
//	// 按原符号位提升
//	// 无符号位，那么按位补0
//	printf("a = %d, b = %d, c = %d\n", a, b, c); // -1 -1 255
//	return 0;
//}


// 输出什么？
//int main()
//{
//	char a = -128;
//	// 10000000 00000000 00000000 10000000 - 原码 
//	// 11111111 11111111 11111111 01111111 - 反码 
//	// 11111111 11111111 11111111 10000000 - 补码 
//	// 10000000
//	// 整型提升
//	// 11111111 11111111 11111111 10000000
//	printf("%u\n", a);	// %u 按无符号打印，认为内存放无符号数，直接放的补码就是和原码反码一样
//	// %d - 打印十进制有符号数字
//	// %u - 打印十进制无符号数字
//	return 0;
//}

// 有符号char的范围 -128 --> 127
// 无符号char的范围 0 --> 255


//int main() 
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);
//	// 按照补码的形式进行运算，最后格式化为有符号整数
//
//	// -20
//	// 10000000 00000000 00000000 00010100 - 原码
//	// 11111111 11111111 11111111 11101011 - 反码
//	// 11111111 11111111 11111111 11101100 - 补码
//
//	// 10
//	// 00000000 00000000 00000000 00001010
//
//	// 进行相加
//	// 11111111 11111111 11111111 11101100
//	// 00000000 00000000 00000000 00001010
//	// 结果如下
//	// 11111111 11111111 11111111 11110110 - 补
//	// 那么它的反码就是
//	// 11111111 11111111 11111111 11110101
//	// 原码就是
//	// 10000000 00000000 00000000 00001010
//	// 所以最终结果应该为 -10
//
//	return 0;
//}


//#include <windows.h>
//
//// 结果打印什么？
//int main() 
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--) 
//	{
//		printf("%u\n", i);
//		Sleep(100);	// 睡上100毫秒
//	}
//	// 无限循环，死循环
//	// unsigned int的范围始终是正数
//	return 0;
//}


// 打印什么？
int main() 
{
	char a[1000];
	int i;
	for (i = 0; i < 1000; i++) 
	{
		a[i] = -1 - i;
	}
	printf("%d", strlen(a));
	// 以为打印1000
	return 0;
}

